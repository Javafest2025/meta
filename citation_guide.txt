â€œImplement robust Citation Checking (local â†¦ web)â€

Context you can rely on

Next.js/React editor app with a LaTeX editor and toolbar. The editor viewâ€‘mode toolbar lives in ViewModeSelector.tsx (shows Editor / Preview / Split)â€”add our new button hereã€ViewModeSelector.tsx

ViewModeSelector

ã€‘.

Main page state and the top action toolbar (Reload, Save, Compile, PDF, etc.) are in page.tsxâ€”we will add state + handlers here and pass props into childrenã€page.tsx

page

ã€‘ã€page.tsx

page

ã€‘.

Selected papers for LaTeX context are managed by PapersSelector.tsx. Use those IDs as the local corpus for stageâ€‘1 checks; they are already loaded in parent state through onPapersLoadã€PapersSelector.tsx

PapersSelector

ã€‘ã€page.tsx

page

ã€‘.

Editor component EnhancedLatexEditor.tsx already supports highlightedRanges?: Array<{ from; to; className }>â€”use this to highlight flagged text spansã€EnhancedLatexEditor.tsx

EnhancedLatexEditor

ã€‘.

The PDF extraction DB already stores structured references and content; in particular, extracted_references contains enriched Crossref/OpenAlex metadata we can leverage for accurate matchingã€PDF_EXTRACTION_DATABASE_SCHEMA.md

PDF_EXTRACTION_DATABASE_SCHEMA

ã€‘.

Product requirement (from the deck): preâ€‘submission checks include â€œverify every reference is citedâ€ etc.â€”this feature implements that promiseã€Javafest2025 (1).pdf

Javafest2025 (1)

ã€‘.

ğŸ§© Goal

Add Citation Check with two stages:

Local check: compare LaTeX content (per .tex file) against the selected context papers (already extracted into our DB).

Web check: if local evidence is weak/missing, perform a broader web search and verification.

Accuracy first:

Do semantic retrieval against the extracted content and references, then ask Gemini to do NLIâ€‘style claim verification with strict thresholds.

Only raise issues when the confidence is above a threshold; otherwise mark as â€œneeds reviewâ€.

UX:

A new Citation Issues button appears beside â€œEditor / Preview / Splitâ€ in the top viewâ€‘mode bar. It is hidden until a result exists; when results exist it shows a count badge.

Clicking opens a drawer/sheet with a filterable list. Hovering an item highlights the exact LaTeX range; clicking scrolls the editor to it.

A progress HUD shows â€œParsing â†’ Local check â†’ Web check â†’ Savingâ€ while the job runs.

Results are saved per .tex file. Reâ€‘running overwrites the previous result for that file.

Store results serverâ€‘side; the button should not reâ€‘run unless the user clicks Recheck.

Backend contract

Weâ€™ll call a citationâ€‘service via REST (youâ€™ll stub endpoints).

Use Gemini (gemini-1.5-pro for reasoning, text-embedding-004 for embeddings).

1) Shared Types (create types/citations.ts)
export type EvidenceSource =
  | { kind: 'local'; paperId: string; paperTitle?: string; sectionId?: string; paragraphId?: string; page?: number }
  | { kind: 'web'; url: string; title?: string; domain?: string };

export type Evidence = {
  source: EvidenceSource;
  matchedText: string;
  similarity: number;            // 0..1 cosine or dot-product normalized
  supportScore: number;          // 0..1 NLI-style â€œsupportsâ€ confidence
};

export type CitationIssueType =
  | 'missing-citation'           // claim likely needs a citation but none present
  | 'weak-citation'              // citation present but doesnâ€™t support claim
  | 'orphan-reference'           // reference in bib never cited
  | 'incorrect-metadata'         // year/title/doi mismatch
  | 'plausible-claim-no-source'  // couldnâ€™t find strong support anywhere
  | 'possible-plagiarism';       // near-duplicate span without citation

export type CitationIssue = {
  id: string;
  projectId: string;
  documentId: string;
  texFileName: string;
  type: CitationIssueType;
  severity: 'low' | 'medium' | 'high';
  // Location in LaTeX
  from: number;   // codepoint offset
  to: number;
  lineStart: number;
  lineEnd: number;
  snippet: string;
  // Bib keys present in the sentence (if any)
  citedKeys: string[];
  // What we think should be cited
  suggestions: Array<{
    kind: 'local' | 'web';
    score: number;
    // local suggestion uses paperId; web uses url
    paperId?: string;
    url?: string;
    bibTex?: string;  // optional generated bib
    title?: string;
    authors?: string[];
    year?: number;
  }>;
  evidence: Evidence[];
  createdAt: string;
};

export type CitationCheckStep =
  | 'PARSING'
  | 'LOCAL_RETRIEVAL'
  | 'LOCAL_VERIFICATION'
  | 'WEB_RETRIEVAL'
  | 'WEB_VERIFICATION'
  | 'SAVING'
  | 'DONE'
  | 'ERROR';

export type CitationCheckJob = {
  jobId: string;
  status: 'QUEUED'|'RUNNING'|'DONE'|'ERROR';
  step: CitationCheckStep;
  progressPct: number;      // 0..100
  summary?: { total: number; byType: Record<CitationIssueType, number> };
  issues?: CitationIssue[];
  errorMessage?: string;
};

2) Backend API (add client in lib/api/latex-service.ts)

Create a citations section and implement these methods:

// POST: start a job
export async function startCitationCheck(params: {
  projectId: string;
  documentId: string;           // the .tex fileâ€™s DB id
  texFileName: string;
  latexContent: string;
  selectedPaperIds: string[];   // from PapersSelector context
  overwrite?: boolean;          // default true
  runWebCheck?: boolean;        // default true
}): Promise<{ jobId: string }> { /* ... */ }

// GET: poll latest status (or use SSE)
export async function getCitationJob(jobId: string): Promise<CitationCheckJob> { /* ... */ }

// GET: latest saved result for a document
export async function getCitationResult(documentId: string): Promise<CitationCheckJob> { /* ... */ }

// PUT: mark an issue resolved/ignored (optional)
export async function updateCitationIssue(issueId: string, patch: Partial<CitationIssue>) { /* ... */ }


Wire these to the following backend routes you will implement (see section 5):

POST   /api/citations/jobs                  -> start
GET    /api/citations/jobs/:jobId           -> status
GET    /api/citations/documents/:docId      -> latest saved job + issues
PUT    /api/citations/issues/:issueId       -> update (optional)
SSE    /api/citations/jobs/:jobId/stream    -> progress events (optional)

3) Frontend UI changes
3.1 Add â€œCitation Issuesâ€ button in the viewâ€‘mode toolbar

In ViewModeSelector.tsx, append a new button to the right of Split; the parent will pass props:

interface ViewModeSelectorProps {
  viewMode: ViewMode;
  onViewModeChange: (mode: ViewMode) => void;
  hasCompiledPdf?: boolean;
  isCompiling?: boolean;
  className?: string;

  // NEW
  citationCount?: number;            // undefined if no run yet
  onOpenCitationPanel?: () => void;  // opens the drawer
  onRunCitationCheck?: () => void;   // kicks a new run
  citationBusy?: boolean;            // show spinner
}

{/* After Split button */}
<button
  type="button"
  onClick={(e) => { e.preventDefault(); onOpenCitationPanel?.(); }}
  className="relative z-50 px-2.5 py-1 text-xs rounded border bg-white dark:bg-slate-700
             text-slate-700 dark:text-slate-300 border-slate-300 dark:border-slate-600
             hover:bg-slate-50 dark:hover:bg-slate-600 cursor-pointer"
  title="View citation issues"
>
  Citation Issues
  {typeof citationCount === 'number' && (
    <span className="ml-1 inline-flex items-center justify-center text-[10px] 
                    rounded-full px-1.5 py-0.5 bg-red-600 text-white">
      {citationCount}
    </span>
  )}
  {citationBusy && <span className="ml-1 h-1.5 w-1.5 bg-orange-500 rounded-full animate-pulse inline-block" />}
</button>


This toolbar is indeed the place showing â€œEditor / Preview / Splitâ€ and optional status indicatorsã€ViewModeSelector.tsx

ViewModeSelector

ã€‘ã€ViewModeSelector.tsx

ViewModeSelector

ã€‘.

3.2 State + wiring in page.tsx

Add state:

const [citationJob, setCitationJob] = useState<CitationCheckJob | null>(null);
const [citationPanelOpen, setCitationPanelOpen] = useState(false);
const [citationBusy, setCitationBusy] = useState(false);


When PapersSelector loads, we already capture selected papers in selectedPapers stateã€page.tsx

page

ã€‘ã€PapersSelector.tsx

PapersSelector

ã€‘. Use their IDs for the local stage.

Add handlers:

const runCitationCheck = async () => {
  if (!currentDocument) return;
  setCitationBusy(true);
  const selectedPaperIds = (selectedPapers || []).map(p => p.id);
  const { jobId } = await latexApi.startCitationCheck({
    projectId,
    documentId: currentDocument.id,
    texFileName: currentDocument.title || 'main.tex',
    latexContent: editorContent,
    selectedPaperIds,
    overwrite: true,
    runWebCheck: true
  });
  // poll
  let done = false;
  while (!done) {
    const job = await latexApi.getCitationJob(jobId);
    setCitationJob(job);
    done = job.status === 'DONE' || job.status === 'ERROR';
    await new Promise(r => setTimeout(r, 1200));
  }
  setCitationBusy(false);
  setCitationPanelOpen(true);
};

const openCitationPanel = async () => {
  if (!currentDocument) return;
  const latest = await latexApi.getCitationResult(currentDocument.id);
  setCitationJob(latest);
  setCitationPanelOpen(true);
};


Pass props into ViewModeSelector:

<ViewModeSelector
  viewMode={viewMode}
  onViewModeChange={setViewMode}
  hasCompiledPdf={!!pdfPreviewUrl}
  isCompiling={isCompiling}
  citationCount={citationJob?.summary?.total}
  citationBusy={citationBusy}
  onOpenCitationPanel={openCitationPanel}
/>


Add a Run entry to your top action toolbar (next to Compile/PDF) that calls runCitationCheck() so users can trigger a fresh run from there tooã€page.tsx

page

ã€‘.

3.3 Add the Citation Issues Drawer

Create components/latex/CitationIssuesPanel.tsx:

Props: { job: CitationCheckJob | null; open: boolean; onOpenChange: (v:boolean)=>void; onJumpToRange?: (from:number,to:number)=>void; onRecheck?: ()=>void }.

Renders a segmented control to filter by type, a search box, issue list, and a progress section when job.status==='RUNNING'.

Each issue shows: type/severity, snippet, suggested citations (local/web), and a â€œCopy BibTeXâ€ button for suggestions.

onMouseEnter of an item: emit a parent callback to set editor highlightedRanges=[{ from,to,className:'bg-red-200/40' }].

Click â†’ scroll the editor to from and briefly flash a beacon (you already have a caret beacon system in EnhancedLatexEditor)ã€EnhancedLatexEditor.tsx

EnhancedLatexEditor

ã€‘.

Mount the panel in page.tsx under the main layout.

3.4 Editor highlighting

EnhancedLatexEditor already accepts highlightedRanges. Ensure it converts those props into CodeMirror decorations (if not implemented, add a small plugin that maps highlightedRanges to Decoration.mark). We already render lots of decorations (inline diff previews); add another field for citation marks with a class like cm-citation-flag. Use the existing extension pattern alongside inlineDiffFieldã€EnhancedLatexEditor.tsx

EnhancedLatexEditor

ã€‘.

4) Persistence model (DB migration)

Create three tables (PostgreSQL):

-- One job per run (overwrites â€œlatestâ€ per document when DONE)
CREATE TABLE citation_checks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL,
  document_id UUID NOT NULL,
  tex_file_name TEXT NOT NULL,
  status TEXT NOT NULL,           -- QUEUED/RUNNING/DONE/ERROR
  step TEXT NOT NULL,             -- enum of CitationCheckStep
  progress_pct INTEGER NOT NULL DEFAULT 0,
  summary JSONB,                  -- { total, byType }
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Issues for a job
CREATE TABLE citation_issues (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id UUID NOT NULL REFERENCES citation_checks(id) ON DELETE CASCADE,
  project_id UUID NOT NULL,
  document_id UUID NOT NULL,
  type TEXT NOT NULL,
  severity TEXT NOT NULL,
  from_pos INTEGER NOT NULL,
  to_pos INTEGER NOT NULL,
  line_start INTEGER NOT NULL,
  line_end INTEGER NOT NULL,
  snippet TEXT NOT NULL,
  cited_keys TEXT[] NOT NULL DEFAULT '{}',
  suggestions JSONB NOT NULL DEFAULT '[]',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Evidence per issue (links to local paperId or web URL)
CREATE TABLE citation_evidence (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  issue_id UUID NOT NULL REFERENCES citation_issues(id) ON DELETE CASCADE,
  source JSONB NOT NULL,         -- { kind:'local'|'web', ... }
  matched_text TEXT NOT NULL,
  similarity DOUBLE PRECISION,
  support_score DOUBLE PRECISION,
  extra JSONB
);

-- Fast â€œlatest per documentâ€
CREATE UNIQUE INDEX citation_latest_doc ON citation_checks(document_id)
  WHERE status = 'DONE';


Notes:

For local evidence, link to the already extracted content in your schema (extracted_references, extracted_paragraphs) to find titles/DOIs etc.ã€PDF_EXTRACTION_DATABASE_SCHEMA.md

PDF_EXTRACTION_DATABASE_SCHEMA

ã€‘.

Use citation_checks(document_id) partial unique index + transaction to overwrite previous â€œDONEâ€ row for same doc.

5) Backend service (FastAPI or Nodeâ€”choose one)

If you already run AI services with FastAPI (Python) per the system design doc, implement this as a new citation-service and expose the REST endpoints aboveã€Javafest2025 (1).pdf

Javafest2025 (1)

ã€‘.

Core pipeline (highâ€‘accuracy)

Input: LaTeX string + selectedPaperIds
Output: CitationCheckJob with issues[].

Steps:

Parse & segment

Strip LaTeX commands except \cite{...} and bibliography.

Create sentence spans with character offsets and line mapping.

Extract cited keys per sentence.

Local retrieval

For each sentence that contains a factual verb or quantifier or any \cite:

Embed sentence with text-embedding-004.

Query a vector index that contains:

Extracted paragraphs/sentences from selected papers.

Enriched bibliographic records from extracted_references (title+abstract, doi)ã€PDF_EXTRACTION_DATABASE_SCHEMA.md

PDF_EXTRACTION_DATABASE_SCHEMA

ã€‘.

Keep topâ€‘k (e.g., 8) candidates.

Local verification (Gemini NLI)

Prompt Gemini 1.5 Pro with claim + candidate snippet pairs; ask for supports | contradicts | not_enough_info + confidence.

Aggregate; if no candidate supports above threshold (e.g., support_score >= 0.66) and the sentence should be cited (heuristics or style rules), create:

missing-citation (no \cite{} present) OR

weak-citation (has \cite{} but supporting evidence doesnâ€™t match the cited paper metadataâ€”use DOI/title match).

Web retrieval

For unresolved/weak candidates, run web search (Semantic Scholar + general search). Fetch snippets (Readability/Boilerpipe-equivalent), deâ€‘dupe.

Reâ€‘run verification with Gemini.

If still no support but the sentence looks like a â€œknown factoidâ€ (dates, first/most/novel), flag as plausible-claim-no-source.

Metadata checks

Parse the paperâ€™s thebibliography/.bib in LaTeX to get cited keys and fields.

Crossâ€‘check keys that never appear in body â†’ orphan-reference.

Validate (title/year/doi) using extracted_references for selected papers + Crossref/OpenAlex fields â†’ incorrect-metadata when mismatch is significantã€PDF_EXTRACTION_DATABASE_SCHEMA.md

PDF_EXTRACTION_DATABASE_SCHEMA

ã€‘.

Plagiarismâ€‘ish

Compute highâ€‘similarity spans against local corpus; if match > 0.95 and no \cite in Â±1 sentence â†’ possible-plagiarism.

Persist & summarize

Save issues + evidence; compute summary counts; upsert as the latest result for documentId.

Gemini usage

Embeddings: text-embedding-004 for sentence and corpus chunks.

Reasoning: gemini-1.5-pro with a strict system prompt:

â€œYou are verifying scientific claims against provided snippets. Output JSON with fields: decision âˆˆ {supports, contradicts, not_enough_info}, rationale (â‰¤50 words), and confidence âˆˆ [0,1]. Only use the snippet text; do not speculate.â€

Minimal FastAPI skeleton
# main.py
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List, Optional
app = FastAPI()

class StartJobReq(BaseModel):
  projectId: str
  documentId: str
  texFileName: str
  latexContent: str
  selectedPaperIds: List[str]
  overwrite: bool = True
  runWebCheck: bool = True

class StartJobResp(BaseModel):
  jobId: str

@app.post("/api/citations/jobs", response_model=StartJobResp)
def start_job(req: StartJobReq):
  # enqueue, return jobId
  ...

@app.get("/api/citations/jobs/{job_id}")
def get_job(job_id: str):
  # return CitationCheckJob JSON
  ...

@app.get("/api/citations/documents/{doc_id}")
def get_latest_for_doc(doc_id: str):
  ...

@app.put("/api/citations/issues/{issue_id}")
def update_issue(issue_id: str, patch: dict):
  ...


Store embeddings in PGVector or a vector store of your choice; corpus: extracted paragraphs of the selected papers (you already have extraction & statuses from PapersSelector, including batch extraction and polling)ã€PapersSelector.tsx

PapersSelector

ã€‘.

Env

GEMINI_API_KEY=...
CITATION_SERVICE_URL=https://...

6) Frontend: integrate with page

Pass selectedPapers from page.tsx to the runCitationCheck call (you already capture them via onPapersLoad)ã€page.tsx

page

ã€‘.

Render the CitationIssuesPanel (drawer). In the list, call setHighlightedRanges([{from: issue.from, to: issue.to, className: 'bg-red-200/40'}]) and scroll the editor to issue.from. If you donâ€™t have a scroll API, place a position marker/beacon near from (you already have a lastâ€‘cursor beacon system)ã€EnhancedLatexEditor.tsx

EnhancedLatexEditor

ã€‘.

7) JSON returned to the client

GET /api/citations/documents/:docId (and jobs/:jobId when DONE) should return:

{
  "jobId":"uuid",
  "status":"DONE",
  "step":"DONE",
  "progressPct":100,
  "summary":{"total":7,"byType":{"missing-citation":3,"weak-citation":2,"orphan-reference":1,"incorrect-metadata":1}},
  "issues":[
    {
      "id":"uuid-1",
      "projectId":"p1",
      "documentId":"d1",
      "texFileName":"main.tex",
      "type":"missing-citation",
      "severity":"high",
      "from":1234,"to":1290,"lineStart":220,"lineEnd":221,
      "snippet":"Prior work shows X improves Y by 30% on task Z.",
      "citedKeys":[],
      "suggestions":[{"kind":"local","score":0.82,"paperId":"paper-123","title":"...","year":2022}],
      "evidence":[
        {"source":{"kind":"local","paperId":"paper-123","page":5},"matchedText":"...","similarity":0.89,"supportScore":0.74}
      ],
      "createdAt":"2025-09-15T10:00:00Z"
    }
  ]
}

8) QA & edge cases

No selected papers â†’ still allow run; local stage is skipped; go straight to web stage with a warning banner in the drawer.

Large .tex â†’ chunk sentences in 1â€“2k char windows; throttle embedding calls; stream progress as steps complete.

Multiple .tex files â†’ job is per documentId; include texFileName in the payload; the â€œCitation Issuesâ€ button reflects the active tabâ€™s document (use your center tabsâ€™ active item id)ã€CenterTabs.tsx

CenterTabs

ã€‘.

Overwrite semantics â†’ when a job finishes, delete older DONE rows for the same (documentId), or rely on the partial unique index described above.

9) What to edit (file-by-file checklist)

types/citations.ts: add types above.

lib/api/latex-service.ts: add startCitationCheck, getCitationJob, getCitationResult, updateCitationIssue.

components/latex/ViewModeSelector.tsx: add â€œCitation Issuesâ€ button + props (see 3.1)ã€ViewModeSelector.tsx

ViewModeSelector

ã€‘.

app/.../page.tsx:

Add citation state + handlers runCitationCheck, openCitationPanel.

Pass citationCount, citationBusy, onOpenCitationPanel to ViewModeSelector.

Add a toolbar button â€œCitation Checkâ€ near Compile/PDF to trigger runCitationCheckã€page.tsx

page

ã€‘.

Mount <CitationIssuesPanel .../> and wire highlighting via EnhancedLatexEditor highlightedRanges.

components/latex/EnhancedLatexEditor.tsx:

If not already implemented, map highlightedRanges to Decoration.mark with class cm-citation-flag. Keep it orthogonal to existing inline diff widgetsã€EnhancedLatexEditor.tsx

EnhancedLatexEditor

ã€‘.

Backend: create citation-service with endpoints from section 5.

10) Prompts for Gemini (verification step)

System:
â€œYou verify scientific claims using only the provided snippets. Reply in strict JSON: {decision,support_sentence_index,confidence,rationale}. decision âˆˆ supports|contradicts|not_enough_info.â€

User:

CLAIM:
"<sentence text>"

CANDIDATE_SNIPPETS:
1) "<snippet-1>"
2) "<snippet-2>"
...
INSTRUCTIONS:
- Evaluate each snippet independently.
- If any snippet supports the claim with confidence â‰¥ 0.66, return decision "supports" with that index.
- Otherwise, if any contradicts with â‰¥ 0.66, return "contradicts".
- Else return "not_enough_info".

11) Success criteria

â€œCitation Issuesâ€ button appears only when at least one saved result exists; shows count badge; clicking opens drawer and highlights locations.

Running a new check updates progress and overwrites the older result for this document.

Local stage leverages selected context papers; the code uses their IDs from PapersSelector (already provided via onPapersLoad)ã€PapersSelector.tsx

PapersSelector

ã€‘.

Issues serialize exactly as CitationIssue[] and are persisted.

Minimal false positives: NLI confidence/thresholds are respected; ambiguous cases labeled â€œneeds reviewâ€ (implement as severity:'low').

(Optional) small UX niceties

In the viewâ€‘mode bar, while a job runs, show a tiny pulsing dot next to the button (we already show â€œCompilingâ€ status similarly)ã€ViewModeSelector.tsx

ViewModeSelector

ã€‘.

In the left Papers panel, surface a hint like â€œExtraction ready for N of Mâ€â€”this already exists via batch extraction; no extra work hereã€PapersSelector.tsx

PapersSelector

ã€‘.