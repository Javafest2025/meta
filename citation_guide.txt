‚ÄúImplement robust Citation Checking (local ‚Ü¶ web)‚Äù

Context you can rely on

Next.js/React editor app with a LaTeX editor and toolbar. The editor view‚Äëmode toolbar lives in ViewModeSelector.tsx (shows Editor / Preview / Split)‚Äîadd our new button here„ÄêViewModeSelector.tsx

ViewModeSelector

„Äë.

Main page state and the top action toolbar (Reload, Save, Compile, PDF, etc.) are in page.tsx‚Äîwe will add state + handlers here and pass props into children„Äêpage.tsx

page

„Äë„Äêpage.tsx

page

„Äë.

Selected papers for LaTeX context are managed by PapersSelector.tsx. Use those IDs as the local corpus for stage‚Äë1 checks; they are already loaded in parent state through onPapersLoad„ÄêPapersSelector.tsx

PapersSelector

„Äë„Äêpage.tsx

page

„Äë.

Editor component EnhancedLatexEditor.tsx already supports highlightedRanges?: Array<{ from; to; className }>‚Äîuse this to highlight flagged text spans„ÄêEnhancedLatexEditor.tsx

EnhancedLatexEditor

„Äë.

The PDF extraction DB already stores structured references and content; in particular, extracted_references contains enriched Crossref/OpenAlex metadata we can leverage for accurate matching„ÄêPDF_EXTRACTION_DATABASE_SCHEMA.md

PDF_EXTRACTION_DATABASE_SCHEMA

„Äë.

Product requirement (from the deck): pre‚Äësubmission checks include ‚Äúverify every reference is cited‚Äù etc.‚Äîthis feature implements that promise„ÄêJavafest2025 (1).pdf

Javafest2025 (1)

„Äë.

üß© Goal

Add Citation Check with two stages:

Local check: compare LaTeX content (per .tex file) against the selected context papers (already extracted into our DB).

Web check: if local evidence is weak/missing, perform a broader web search and verification.

Accuracy first:

Do semantic retrieval against the extracted content and references, then ask Gemini to do NLI‚Äëstyle claim verification with strict thresholds.

Only raise issues when the confidence is above a threshold; otherwise mark as ‚Äúneeds review‚Äù.

UX:

A new Citation Issues button appears beside ‚ÄúEditor / Preview / Split‚Äù in the top view‚Äëmode bar. It is hidden until a result exists; when results exist it shows a count badge.

Clicking opens a drawer/sheet with a filterable list. Hovering an item highlights the exact LaTeX range; clicking scrolls the editor to it.

A progress HUD shows ‚ÄúParsing ‚Üí Local check ‚Üí Web check ‚Üí Saving‚Äù while the job runs.

Results are saved per .tex file. Re‚Äërunning overwrites the previous result for that file.

Store results server‚Äëside; the button should not re‚Äërun unless the user clicks Recheck.

Backend contract

We‚Äôll call a citation‚Äëservice via REST (you‚Äôll stub endpoints).

Use Gemini (gemini-1.5-pro for reasoning, text-embedding-004 for embeddings).

1) Shared Types (create types/citations.ts)
export type EvidenceSource =
  | { kind: 'local'; paperId: string; paperTitle?: string; sectionId?: string; paragraphId?: string; page?: number }
  | { kind: 'web'; url: string; title?: string; domain?: string };

export type Evidence = {
  source: EvidenceSource;
  matchedText: string;
  similarity: number;            // 0..1 cosine or dot-product normalized
  supportScore: number;          // 0..1 NLI-style ‚Äúsupports‚Äù confidence
};

export type CitationIssueType =
  | 'missing-citation'           // claim likely needs a citation but none present
  | 'weak-citation'              // citation present but doesn‚Äôt support claim
  | 'orphan-reference'           // reference in bib never cited
  | 'incorrect-metadata'         // year/title/doi mismatch
  | 'plausible-claim-no-source'  // couldn‚Äôt find strong support anywhere
  | 'possible-plagiarism';       // near-duplicate span without citation

export type CitationIssue = {
  id: string;
  projectId: string;
  documentId: string;
  texFileName: string;
  type: CitationIssueType;
  severity: 'low' | 'medium' | 'high';
  // Location in LaTeX
  from: number;   // codepoint offset
  to: number;
  lineStart: number;
  lineEnd: number;
  snippet: string;
  // Bib keys present in the sentence (if any)
  citedKeys: string[];
  // What we think should be cited
  suggestions: Array<{
    kind: 'local' | 'web';
    score: number;
    // local suggestion uses paperId; web uses url
    paperId?: string;
    url?: string;
    bibTex?: string;  // optional generated bib
    title?: string;
    authors?: string[];
    year?: number;
  }>;
  evidence: Evidence[];
  createdAt: string;
};

export type CitationCheckStep =
  | 'PARSING'
  | 'LOCAL_RETRIEVAL'
  | 'LOCAL_VERIFICATION'
  | 'WEB_RETRIEVAL'
  | 'WEB_VERIFICATION'
  | 'SAVING'
  | 'DONE'
  | 'ERROR';

export type CitationCheckJob = {
  jobId: string;
  status: 'QUEUED'|'RUNNING'|'DONE'|'ERROR';
  step: CitationCheckStep;
  progressPct: number;      // 0..100
  summary?: { total: number; byType: Record<CitationIssueType, number> };
  issues?: CitationIssue[];
  errorMessage?: string;
};

2) Backend API (add client in lib/api/latex-service.ts)

Create a citations section and implement these methods:

// POST: start a job
export async function startCitationCheck(params: {
  projectId: string;
  documentId: string;           // the .tex file‚Äôs DB id
  texFileName: string;
  latexContent: string;
  selectedPaperIds: string[];   // from PapersSelector context
  overwrite?: boolean;          // default true
  runWebCheck?: boolean;        // default true
}): Promise<{ jobId: string }> { /* ... */ }

// GET: poll latest status (or use SSE)
export async function getCitationJob(jobId: string): Promise<CitationCheckJob> { /* ... */ }

// GET: latest saved result for a document
export async function getCitationResult(documentId: string): Promise<CitationCheckJob> { /* ... */ }

// PUT: mark an issue resolved/ignored (optional)
export async function updateCitationIssue(issueId: string, patch: Partial<CitationIssue>) { /* ... */ }


Wire these to the following backend routes you will implement (see section 5):

POST   /api/citations/jobs                  -> start
GET    /api/citations/jobs/:jobId           -> status
GET    /api/citations/documents/:docId      -> latest saved job + issues
PUT    /api/citations/issues/:issueId       -> update (optional)
SSE    /api/citations/jobs/:jobId/stream    -> progress events (optional)

3) Frontend UI changes
3.1 Add ‚ÄúCitation Issues‚Äù button in the view‚Äëmode toolbar

In ViewModeSelector.tsx, append a new button to the right of Split; the parent will pass props:

interface ViewModeSelectorProps {
  viewMode: ViewMode;
  onViewModeChange: (mode: ViewMode) => void;
  hasCompiledPdf?: boolean;
  isCompiling?: boolean;
  className?: string;

  // NEW
  citationCount?: number;            // undefined if no run yet
  onOpenCitationPanel?: () => void;  // opens the drawer
  onRunCitationCheck?: () => void;   // kicks a new run
  citationBusy?: boolean;            // show spinner
}

{/* After Split button */}
<button
  type="button"
  onClick={(e) => { e.preventDefault(); onOpenCitationPanel?.(); }}
  className="relative z-50 px-2.5 py-1 text-xs rounded border bg-white dark:bg-slate-700
             text-slate-700 dark:text-slate-300 border-slate-300 dark:border-slate-600
             hover:bg-slate-50 dark:hover:bg-slate-600 cursor-pointer"
  title="View citation issues"
>
  Citation Issues
  {typeof citationCount === 'number' && (
    <span className="ml-1 inline-flex items-center justify-center text-[10px] 
                    rounded-full px-1.5 py-0.5 bg-red-600 text-white">
      {citationCount}
    </span>
  )}
  {citationBusy && <span className="ml-1 h-1.5 w-1.5 bg-orange-500 rounded-full animate-pulse inline-block" />}
</button>


This toolbar is indeed the place showing ‚ÄúEditor / Preview / Split‚Äù and optional status indicators„ÄêViewModeSelector.tsx

ViewModeSelector

„Äë„ÄêViewModeSelector.tsx

ViewModeSelector

„Äë.

3.2 State + wiring in page.tsx

Add state:

const [citationJob, setCitationJob] = useState<CitationCheckJob | null>(null);
const [citationPanelOpen, setCitationPanelOpen] = useState(false);
const [citationBusy, setCitationBusy] = useState(false);


When PapersSelector loads, we already capture selected papers in selectedPapers state„Äêpage.tsx

page

„Äë„ÄêPapersSelector.tsx

PapersSelector

„Äë. Use their IDs for the local stage.

Add handlers:

const runCitationCheck = async () => {
  if (!currentDocument) return;
  setCitationBusy(true);
  const selectedPaperIds = (selectedPapers || []).map(p => p.id);
  const { jobId } = await latexApi.startCitationCheck({
    projectId,
    documentId: currentDocument.id,
    texFileName: currentDocument.title || 'main.tex',
    latexContent: editorContent,
    selectedPaperIds,
    overwrite: true,
    runWebCheck: true
  });
  // poll
  let done = false;
  while (!done) {
    const job = await latexApi.getCitationJob(jobId);
    setCitationJob(job);
    done = job.status === 'DONE' || job.status === 'ERROR';
    await new Promise(r => setTimeout(r, 1200));
  }
  setCitationBusy(false);
  setCitationPanelOpen(true);
};

const openCitationPanel = async () => {
  if (!currentDocument) return;
  const latest = await latexApi.getCitationResult(currentDocument.id);
  setCitationJob(latest);
  setCitationPanelOpen(true);
};


Pass props into ViewModeSelector:

<ViewModeSelector
  viewMode={viewMode}
  onViewModeChange={setViewMode}
  hasCompiledPdf={!!pdfPreviewUrl}
  isCompiling={isCompiling}
  citationCount={citationJob?.summary?.total}
  citationBusy={citationBusy}
  onOpenCitationPanel={openCitationPanel}
/>


Add a Run entry to your top action toolbar (next to Compile/PDF) that calls runCitationCheck() so users can trigger a fresh run from there too„Äêpage.tsx

page

„Äë.

3.3 Add the Citation Issues Drawer

Create components/latex/CitationIssuesPanel.tsx:

Props: { job: CitationCheckJob | null; open: boolean; onOpenChange: (v:boolean)=>void; onJumpToRange?: (from:number,to:number)=>void; onRecheck?: ()=>void }.

Renders a segmented control to filter by type, a search box, issue list, and a progress section when job.status==='RUNNING'.

Each issue shows: type/severity, snippet, suggested citations (local/web), and a ‚ÄúCopy BibTeX‚Äù button for suggestions.

onMouseEnter of an item: emit a parent callback to set editor highlightedRanges=[{ from,to,className:'bg-red-200/40' }].

Click ‚Üí scroll the editor to from and briefly flash a beacon (you already have a caret beacon system in EnhancedLatexEditor)„ÄêEnhancedLatexEditor.tsx

EnhancedLatexEditor

„Äë.

Mount the panel in page.tsx under the main layout.

3.4 Editor highlighting

EnhancedLatexEditor already accepts highlightedRanges. Ensure it converts those props into CodeMirror decorations (if not implemented, add a small plugin that maps highlightedRanges to Decoration.mark). We already render lots of decorations (inline diff previews); add another field for citation marks with a class like cm-citation-flag. Use the existing extension pattern alongside inlineDiffField„ÄêEnhancedLatexEditor.tsx

EnhancedLatexEditor

„Äë.

4) Persistence model (DB migration)

Create three tables (PostgreSQL):

-- One job per run (overwrites ‚Äúlatest‚Äù per document when DONE)
CREATE TABLE citation_checks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL,
  document_id UUID NOT NULL,
  tex_file_name TEXT NOT NULL,
  status TEXT NOT NULL,           -- QUEUED/RUNNING/DONE/ERROR
  step TEXT NOT NULL,             -- enum of CitationCheckStep
  progress_pct INTEGER NOT NULL DEFAULT 0,
  summary JSONB,                  -- { total, byType }
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Issues for a job
CREATE TABLE citation_issues (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id UUID NOT NULL REFERENCES citation_checks(id) ON DELETE CASCADE,
  project_id UUID NOT NULL,
  document_id UUID NOT NULL,
  type TEXT NOT NULL,
  severity TEXT NOT NULL,
  from_pos INTEGER NOT NULL,
  to_pos INTEGER NOT NULL,
  line_start INTEGER NOT NULL,
  line_end INTEGER NOT NULL,
  snippet TEXT NOT NULL,
  cited_keys TEXT[] NOT NULL DEFAULT '{}',
  suggestions JSONB NOT NULL DEFAULT '[]',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Evidence per issue (links to local paperId or web URL)
CREATE TABLE citation_evidence (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  issue_id UUID NOT NULL REFERENCES citation_issues(id) ON DELETE CASCADE,
  source JSONB NOT NULL,         -- { kind:'local'|'web', ... }
  matched_text TEXT NOT NULL,
  similarity DOUBLE PRECISION,
  support_score DOUBLE PRECISION,
  extra JSONB
);

-- Fast ‚Äúlatest per document‚Äù
CREATE UNIQUE INDEX citation_latest_doc ON citation_checks(document_id)
  WHERE status = 'DONE';


Notes:

For local evidence, link to the already extracted content in your schema (extracted_references, extracted_paragraphs) to find titles/DOIs etc.„ÄêPDF_EXTRACTION_DATABASE_SCHEMA.md

PDF_EXTRACTION_DATABASE_SCHEMA

„Äë.

Use citation_checks(document_id) partial unique index + transaction to overwrite previous ‚ÄúDONE‚Äù row for same doc.

5) Backend service (FastAPI or Node‚Äîchoose one)

If you already run AI services with FastAPI (Python) per the system design doc, implement this as a new citation-service and expose the REST endpoints above„ÄêJavafest2025 (1).pdf

Javafest2025 (1)

„Äë.

Core pipeline (high‚Äëaccuracy)

Input: LaTeX string + selectedPaperIds
Output: CitationCheckJob with issues[].

Steps:

Parse & segment

Strip LaTeX commands except \cite{...} and bibliography.

Create sentence spans with character offsets and line mapping.

Extract cited keys per sentence.

Local retrieval

For each sentence that contains a factual verb or quantifier or any \cite:

Embed sentence with text-embedding-004.

Query a vector index that contains:

Extracted paragraphs/sentences from selected papers.

Enriched bibliographic records from extracted_references (title+abstract, doi)„ÄêPDF_EXTRACTION_DATABASE_SCHEMA.md

PDF_EXTRACTION_DATABASE_SCHEMA

„Äë.

Keep top‚Äëk (e.g., 8) candidates.

Local verification (Gemini NLI)

Prompt Gemini 1.5 Pro with claim + candidate snippet pairs; ask for supports | contradicts | not_enough_info + confidence.

Aggregate; if no candidate supports above threshold (e.g., support_score >= 0.66) and the sentence should be cited (heuristics or style rules), create:

missing-citation (no \cite{} present) OR

weak-citation (has \cite{} but supporting evidence doesn‚Äôt match the cited paper metadata‚Äîuse DOI/title match).

Web retrieval

For unresolved/weak candidates, run web search (Semantic Scholar + general search). Fetch snippets (Readability/Boilerpipe-equivalent), de‚Äëdupe.

Re‚Äërun verification with Gemini.

If still no support but the sentence looks like a ‚Äúknown factoid‚Äù (dates, first/most/novel), flag as plausible-claim-no-source.

Metadata checks

Parse the paper‚Äôs thebibliography/.bib in LaTeX to get cited keys and fields.

Cross‚Äëcheck keys that never appear in body ‚Üí orphan-reference.

Validate (title/year/doi) using extracted_references for selected papers + Crossref/OpenAlex fields ‚Üí incorrect-metadata when mismatch is significant„ÄêPDF_EXTRACTION_DATABASE_SCHEMA.md

PDF_EXTRACTION_DATABASE_SCHEMA

„Äë.

Plagiarism‚Äëish

Compute high‚Äësimilarity spans against local corpus; if match > 0.95 and no \cite in ¬±1 sentence ‚Üí possible-plagiarism.

Persist & summarize

Save issues + evidence; compute summary counts; upsert as the latest result for documentId.

Gemini usage

Embeddings: text-embedding-004 for sentence and corpus chunks.

Reasoning: gemini-1.5-pro with a strict system prompt:

‚ÄúYou are verifying scientific claims against provided snippets. Output JSON with fields: decision ‚àà {supports, contradicts, not_enough_info}, rationale (‚â§50 words), and confidence ‚àà [0,1]. Only use the snippet text; do not speculate.‚Äù

Minimal FastAPI skeleton
# main.py
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List, Optional
app = FastAPI()

class StartJobReq(BaseModel):
  projectId: str
  documentId: str
  texFileName: str
  latexContent: str
  selectedPaperIds: List[str]
  overwrite: bool = True
  runWebCheck: bool = True

class StartJobResp(BaseModel):
  jobId: str

@app.post("/api/citations/jobs", response_model=StartJobResp)
def start_job(req: StartJobReq):
  # enqueue, return jobId
  ...

@app.get("/api/citations/jobs/{job_id}")
def get_job(job_id: str):
  # return CitationCheckJob JSON
  ...

@app.get("/api/citations/documents/{doc_id}")
def get_latest_for_doc(doc_id: str):
  ...

@app.put("/api/citations/issues/{issue_id}")
def update_issue(issue_id: str, patch: dict):
  ...


Store embeddings in PGVector or a vector store of your choice; corpus: extracted paragraphs of the selected papers (you already have extraction & statuses from PapersSelector, including batch extraction and polling)„ÄêPapersSelector.tsx

PapersSelector

„Äë.

Env

GEMINI_API_KEY=...
CITATION_SERVICE_URL=https://...

6) Frontend: integrate with page

Pass selectedPapers from page.tsx to the runCitationCheck call (you already capture them via onPapersLoad)„Äêpage.tsx

page

„Äë.

Render the CitationIssuesPanel (drawer). In the list, call setHighlightedRanges([{from: issue.from, to: issue.to, className: 'bg-red-200/40'}]) and scroll the editor to issue.from. If you don‚Äôt have a scroll API, place a position marker/beacon near from (you already have a last‚Äëcursor beacon system)„ÄêEnhancedLatexEditor.tsx

EnhancedLatexEditor

„Äë.

7) JSON returned to the client

GET /api/citations/documents/:docId (and jobs/:jobId when DONE) should return:

{
  "jobId":"uuid",
  "status":"DONE",
  "step":"DONE",
  "progressPct":100,
  "summary":{"total":7,"byType":{"missing-citation":3,"weak-citation":2,"orphan-reference":1,"incorrect-metadata":1}},
  "issues":[
    {
      "id":"uuid-1",
      "projectId":"p1",
      "documentId":"d1",
      "texFileName":"main.tex",
      "type":"missing-citation",
      "severity":"high",
      "from":1234,"to":1290,"lineStart":220,"lineEnd":221,
      "snippet":"Prior work shows X improves Y by 30% on task Z.",
      "citedKeys":[],
      "suggestions":[{"kind":"local","score":0.82,"paperId":"paper-123","title":"...","year":2022}],
      "evidence":[
        {"source":{"kind":"local","paperId":"paper-123","page":5},"matchedText":"...","similarity":0.89,"supportScore":0.74}
      ],
      "createdAt":"2025-09-15T10:00:00Z"
    }
  ]
}

8) QA & edge cases

No selected papers ‚Üí still allow run; local stage is skipped; go straight to web stage with a warning banner in the drawer.

Large .tex ‚Üí chunk sentences in 1‚Äì2k char windows; throttle embedding calls; stream progress as steps complete.

Multiple .tex files ‚Üí job is per documentId; include texFileName in the payload; the ‚ÄúCitation Issues‚Äù button reflects the active tab‚Äôs document (use your center tabs‚Äô active item id)„ÄêCenterTabs.tsx

CenterTabs

„Äë.

Overwrite semantics ‚Üí when a job finishes, delete older DONE rows for the same (documentId), or rely on the partial unique index described above.

9) What to edit (file-by-file checklist)

types/citations.ts: add types above.

lib/api/latex-service.ts: add startCitationCheck, getCitationJob, getCitationResult, updateCitationIssue.

components/latex/ViewModeSelector.tsx: add ‚ÄúCitation Issues‚Äù button + props (see 3.1)„ÄêViewModeSelector.tsx

ViewModeSelector

„Äë.

app/.../page.tsx:

Add citation state + handlers runCitationCheck, openCitationPanel.

Pass citationCount, citationBusy, onOpenCitationPanel to ViewModeSelector.

Add a toolbar button ‚ÄúCitation Check‚Äù near Compile/PDF to trigger runCitationCheck„Äêpage.tsx

page

„Äë.

Mount <CitationIssuesPanel .../> and wire highlighting via EnhancedLatexEditor highlightedRanges.

components/latex/EnhancedLatexEditor.tsx:

If not already implemented, map highlightedRanges to Decoration.mark with class cm-citation-flag. Keep it orthogonal to existing inline diff widgets„ÄêEnhancedLatexEditor.tsx

EnhancedLatexEditor

„Äë.

Backend: create citation-service with endpoints from section 5.

10) Prompts for Gemini (verification step)

System:
‚ÄúYou verify scientific claims using only the provided snippets. Reply in strict JSON: {decision,support_sentence_index,confidence,rationale}. decision ‚àà supports|contradicts|not_enough_info.‚Äù

User:

CLAIM:
"<sentence text>"

CANDIDATE_SNIPPETS:
1) "<snippet-1>"
2) "<snippet-2>"
...
INSTRUCTIONS:
- Evaluate each snippet independently.
- If any snippet supports the claim with confidence ‚â• 0.66, return decision "supports" with that index.
- Otherwise, if any contradicts with ‚â• 0.66, return "contradicts".
- Else return "not_enough_info".

11) Success criteria

‚ÄúCitation Issues‚Äù button appears only when at least one saved result exists; shows count badge; clicking opens drawer and highlights locations.

Running a new check updates progress and overwrites the older result for this document.

Local stage leverages selected context papers; the code uses their IDs from PapersSelector (already provided via onPapersLoad)„ÄêPapersSelector.tsx

PapersSelector

„Äë.

Issues serialize exactly as CitationIssue[] and are persisted.

Minimal false positives: NLI confidence/thresholds are respected; ambiguous cases labeled ‚Äúneeds review‚Äù (implement as severity:'low').

(Optional) small UX niceties

In the view‚Äëmode bar, while a job runs, show a tiny pulsing dot next to the button (we already show ‚ÄúCompiling‚Äù status similarly)„ÄêViewModeSelector.tsx

ViewModeSelector

„Äë.

In the left Papers panel, surface a hint like ‚ÄúExtraction ready for N of M‚Äù‚Äîthis already exists via batch extraction; no extra work here„ÄêPapersSelector.tsx

PapersSelector

„Äë.